<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏≠ÊñáËØçÊ±áÊµãÈ™å</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Keyframe animations for a more dynamic UI */
        @keyframes scaleIn {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideInLeft {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes scaleUp {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .animate-scaleIn { animation: scaleIn 0.5s ease-out forwards; }
        .animate-fadeIn { animation: fadeIn 0.5s ease-out forwards; }
        .animate-slideInLeft { animation: slideInLeft 0.5s ease-out forwards; }
        .animate-bounce { animation: bounce 1s infinite; }
        .animate-scaleUp { animation: scaleUp 0.3s ease-in-out forwards; }
        .delay-100 { animation-delay: 0.1s; }
    </style>
</head>
<body class="bg-gray-100">

    <div id="root"></div>

    <!-- React, ReactDOM, and Babel from CDN. This allows us to write JSX directly. -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- The entire React application logic, now using JSX for readability. -->
    <script type="text/babel">
        // Helper functions for the Gemini TTS API
        // Converts a base64 string to an ArrayBuffer.
        const base64ToArrayBuffer = (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        };
        
        // Converts PCM audio data to a WAV blob for playback.
        const pcmToWav = (pcmData, sampleRate) => {
            const dataLength = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            // WAV file header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset, pcmData[i], true);
                offset += 2;
            }
            
            return new Blob([view], { type: 'audio/wav' });
        };
        
        // Helper to write string to DataView.
        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        // Define the quiz questions as an array of objects.
        const questions = [
            {
                type: 'multiple-choice',
                questionText: '‚ÄúÂ∞èÊòéÊòØ‰∏Ä‰∏™Âæà**Âã§Â•ã**ÁöÑÂ≠¶Áîü„ÄÇ‚Äù Âã§Â•ãÁöÑÊÑèÊÄùÊòØ?',
                targetWord: 'Âã§Â•ã',
                answerOptions: [
                    { answerText: 'ÂñúÊ¨¢Áé©ËÄç', isCorrect: false },
                    { answerText: 'Áî®ÂäüÂä™Âäõ', isCorrect: true },
                    { answerText: 'Âä®‰ΩúÂæàÂø´', isCorrect: false },
                    { answerText: 'ÂñúÊ¨¢Áù°Ëßâ', isCorrect: false },
                ],
                pinyin: 'q√≠n f√®n',
            },
            {
                type: 'fill-in-the-blank',
                questionText: '‰ªñÁúãÂà∞Â¶àÂ¶àÂæàÁ¥ØÔºåÂ∞±‰∏ªÂä®Âéª______„ÄÇ (Â∏Æ)',
                targetWord: 'Â∏ÆÂøô',
                answerText: 'Â∏ÆÂøô',
                pinyin: 'bƒÅng m√°ng',
            },
            {
                type: 'multiple-choice',
                questionText: '‚ÄúËÄÅÂ∏àÂØπÊàëÁöÑË°®Áé∞Âæà**Êª°ÊÑè**„ÄÇ‚Äù Êª°ÊÑèÊòØ‰ªÄ‰πàÊÑèÊÄù?',
                targetWord: 'Êª°ÊÑè',
                answerOptions: [
                    { answerText: 'ÊÑüÂà∞È´òÂÖ¥„ÄÅÁ¨¶ÂêàÂøÉÊÑø', isCorrect: true },
                    { answerText: 'ÊÑüÂà∞ÂæàÁîüÊ∞î', isCorrect: false },
                    { answerText: 'ÊÑüÂà∞Âæà‰º§ÂøÉ', isCorrect: false },
                    { answerText: 'ÊÑüÂà∞ÂæàÂÆ≥ÊÄï', isCorrect: false },
                ],
                pinyin: 'm«én y√¨',
            },
            {
                type: 'fill-in-the-blank',
                questionText: '‰ªäÂ§©ÁöÑÂ§©Ê∞îÁúüÂ•ΩÔºåÂæà______„ÄÇ (Ê∏©Êöñ)',
                targetWord: 'Ê∏©Êöñ',
                answerText: 'Ê∏©Êöñ',
                pinyin: 'wƒìn nu«én',
            },
            {
                type: 'multiple-choice',
                questionText: '‚Äú‰ªñÁöÑÊàøÈó¥Âæà**Êï¥ÈΩê**„ÄÇ‚Äù Êï¥ÈΩêÁöÑÂèç‰πâËØçÊòØ?',
                targetWord: 'Êï¥ÈΩê',
                answerOptions: [
                    { answerText: 'Âπ≤ÂáÄ', isCorrect: false },
                    { answerText: 'ÊºÇ‰∫Æ', isCorrect: false },
                    { answerText: 'Âáå‰π±', isCorrect: true },
                    { answerText: 'Â∑®Â§ß', isCorrect: false },
                ],
                pinyin: 'zhƒõng q√≠',
            },
            {
                type: 'fill-in-the-blank',
                questionText: 'ÂêåÂ≠¶‰ª¨ÈÉΩÈùûÂ∏∏______Êñ∞ËÄÅÂ∏àÁöÑÂà∞Êù•„ÄÇ (Ê¨¢Ëøé)',
                targetWord: 'Ê¨¢Ëøé',
                answerText: 'Ê¨¢Ëøé',
                pinyin: 'huƒÅn y√≠ng',
            },
            {
                type: 'multiple-choice',
                questionText: '‚ÄúÊàë**Áªà‰∫é**Êää‰Ωú‰∏öÂÅöÂÆå‰∫ÜÔºÅ‚Äù Áªà‰∫éÁöÑÊÑèÊÄùÊòØ?',
                targetWord: 'Áªà‰∫é',
                answerOptions: [
                    { answerText: 'ÂàöÂàöÂºÄÂßã', isCorrect: false },
                    { answerText: 'ÊúÄÂêé„ÄÅÁªèËøáÊº´ÈïøÁ≠âÂæÖ', isCorrect: true },
                    { answerText: 'Áé∞Âú®Á´ãÂàª', isCorrect: false },
                    { answerText: 'ÊúâÊó∂ÂÄô', isCorrect: false },
                ],
                pinyin: 'zh≈çng y√∫',
            },
            {
                type: 'fill-in-the-blank',
                questionText: 'Êàë‰ª¨Â∫îËØ•______Â∏ÆÂä©ÊúâÂõ∞ÈöæÁöÑ‰∫∫„ÄÇ (‰πê‰∫é)',
                targetWord: '‰πê‰∫é',
                answerText: '‰πê‰∫é',
                pinyin: 'l√® y√∫',
            },
            {
                type: 'multiple-choice',
                questionText: '‚ÄúÊàëÈùûÂ∏∏**‰Ω©Êúç**‰ªñÁöÑÂãáÊ∞î„ÄÇ‚Äù ‰Ω©ÊúçÁöÑÊÑèÊÄùÊòØ?',
                targetWord: '‰Ω©Êúç',
                answerOptions: [
                    { answerText: 'Áúã‰∏çËµ∑', isCorrect: false },
                    { answerText: 'Â∞äÊï¨ÂíåÈí¶‰Ω©', isCorrect: true },
                    { answerText: 'Âò≤Á¨ë', isCorrect: false },
                    { answerText: 'ÂÆ≥ÊÄï', isCorrect: false },
                ],
                pinyin: 'p√®i f√∫',
            },
            {
                type: 'fill-in-the-blank',
                questionText: 'Êàë‰ª¨Ë¶ÅÁà±Êä§ÁéØÂ¢ÉÔºå‰øùÊä§Âú∞ÁêÉ‰∏äÁöÑ______„ÄÇ (ËµÑÊ∫ê)',
                targetWord: 'ËµÑÊ∫ê',
                answerText: 'ËµÑÊ∫ê',
                pinyin: 'zƒ´ yu√°n',
            },
            {
                type: 'multiple-choice',
                questionText: '‚ÄúËøô‰∏™ÊïÖ‰∫ãÂæà**Á≤æÂΩ©**„ÄÇ‚Äù Á≤æÂΩ©ÊòØ‰ªÄ‰πàÊÑèÊÄù?',
                targetWord: 'Á≤æÂΩ©',
                answerOptions: [
                    { answerText: 'Êó†ËÅä„ÄÅ‰πèÂë≥', isCorrect: false },
                    { answerText: 'ÂÜÖÂÆπ‰∏∞ÂØå„ÄÅÂá∫Ëâ≤', isCorrect: true },
                    { answerText: 'Âπ≥Ê∑°Êó†Â•á', isCorrect: false },
                    { answerText: 'ÂæàÁü≠', isCorrect: false },
                ],
                pinyin: 'jƒ´ng c«éi',
            },
            {
                type: 'fill-in-the-blank',
                questionText: 'Êàë______Âà∞ÊòéÂ§©ËÉΩÂéªÂÖ¨Âõ≠Áé©„ÄÇ (Â∏åÊúõ)',
                targetWord: 'Â∏åÊúõ',
                answerText: 'Â∏åÊúõ',
                pinyin: 'xƒ´ w√†ng',
            },
            {
                type: 'multiple-choice',
                questionText: '‚Äú‰ªñÊòØ‰∏Ä‰∏™Âæà**ËØöÂÆû**ÁöÑÂ≠©Â≠ê„ÄÇ‚Äù ËØöÂÆûÁöÑÂèç‰πâËØçÊòØ?',
                targetWord: 'ËØöÂÆû',
                answerOptions: [
                    { answerText: 'ÂãáÊï¢', isCorrect: false },
                    { answerText: 'ÂñÑËâØ', isCorrect: false },
                    { answerText: 'Ëôö‰º™', isCorrect: true },
                    { answerText: 'ÂÆ≥Áæû', isCorrect: false },
                ],
                pinyin: 'ch√©ng sh√≠',
            },
            {
                type: 'fill-in-the-blank',
                questionText: 'ÊàëÁöÑ______ÊòØÈïøÂ§ßÂêéÊàê‰∏∫‰∏ÄÂêçÂåªÁîü„ÄÇ (ÁêÜÊÉ≥)',
                targetWord: 'ÁêÜÊÉ≥',
                answerText: 'ÁêÜÊÉ≥',
                pinyin: 'l«ê xi«éng',
            },
            {
                type: 'multiple-choice',
                questionText: '‚Äú‰ªñ**‰∏•ËÇÉ**Âú∞ÁúãÁùÄÊàë„ÄÇ‚Äù ‰∏•ËÇÉÊòØ‰ªÄ‰πàÊÑèÊÄù?',
                targetWord: '‰∏•ËÇÉ',
                answerOptions: [
                    { answerText: 'ÂæàÂºÄÂøÉ„ÄÅÂ§ßÁ¨ë', isCorrect: false },
                    { answerText: 'Á•ûÊÉÖÂ∫ÑÈáç„ÄÅ‰∏çËãüË®ÄÁ¨ë', isCorrect: true },
                    { answerText: 'ÂæàË∞ÉÁöÆ', isCorrect: false },
                    { answerText: 'ÂæàÊîæÊùæ', isCorrect: false },
                ],
                pinyin: 'y√°n s√π',
            },
        ];

        // The main App component for our Chinese vocabulary quiz.
        const App = () => {
            const [currentQuestion, setCurrentQuestion] = React.useState(0);
            const [showScore, setShowScore] = React.useState(false);
            const [score, setScore] = React.useState(0);
            const [answered, setAnswered] = React.useState(false);
            const [lastCorrect, setLastCorrect] = React.useState(null);
            const [fillInAnswer, setFillInAnswer] = React.useState('');
            const [hint, setHint] = React.useState('');
            const [isHintLoading, setIsHintLoading] = React.useState(false);
            const [isSpeaking, setIsSpeaking] = React.useState(false);

            // Function to handle the user's answer selection for multiple-choice questions.
            const handleMultipleChoiceClick = (isCorrect) => {
                if (answered) return;
                
                if (isCorrect) {
                    setScore(score + 1);
                }
                
                setLastCorrect(isCorrect);
                setAnswered(true);
            };
            
            // Function to handle the submission of a fill-in-the-blank answer.
            const handleFillInSubmit = () => {
                if (answered) return;
                const isCorrect = fillInAnswer.trim().toLowerCase() === questions[currentQuestion].answerText.trim().toLowerCase();
                if (isCorrect) {
                    setScore(score + 1);
                }
                setLastCorrect(isCorrect);
                setAnswered(true);
            };

            // Function to handle moving to the next question.
            const handleNextQuestion = () => {
                const nextQuestion = currentQuestion + 1;
                if (nextQuestion < questions.length) {
                    setCurrentQuestion(nextQuestion);
                    setAnswered(false);
                    setLastCorrect(null);
                    setFillInAnswer('');
                    setHint('');
                } else {
                    setShowScore(true);
                }
            };

            // Function to restart the quiz.
            const handleRestartQuiz = () => {
                setCurrentQuestion(0);
                setScore(0);
                setShowScore(false);
                setAnswered(false);
                setLastCorrect(null);
                setFillInAnswer('');
                setHint('');
            };

            // Function to get a hint using the Gemini API
            const handleGetHint = async () => {
                setIsHintLoading(true);
                setHint('');
                try {
                    const targetWord = questions[currentQuestion].targetWord;
                    const prompt = `Please provide a simple and friendly English explanation for the Chinese word "${targetWord}". Also, include a short example sentence in Chinese with its English translation. The explanation should be suitable for a Primary 6 student in Singapore and no more than 50 words.`;
                    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = "AIzaSyAsw0vcxoFVumtEqE8e5cCq2Z_f_7MtVeY";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    const result = await response.json();
                    const generatedText = result.candidates[0].content.parts[0].text;
                    setHint(generatedText);
                } catch (error) {
                    console.error('Error generating hint:', error);
                    setHint('Êä±Ê≠âÔºåËé∑ÂèñÊèêÁ§∫Êó∂Âá∫Èîô„ÄÇËØ∑ÂÜçËØï‰∏ÄÊ¨°„ÄÇ (Sorry, there was an error getting the hint. Please try again.)');
                } finally {
                    setIsHintLoading(false);
                }
            };

            // Function to handle Text-to-Speech using the Gemini API
            const handleTextToSpeech = async () => {
                if (isSpeaking) return;
                setIsSpeaking(true);
                try {
                    const textToSpeak = questions[currentQuestion].questionText;
                    const payload = {
                        contents: [{ parts: [{ text: `Say in a gentle voice: ${textToSpeak}` }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: "Achird" }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };
                    const apiKey = "AIzaSyAsw0vcxoFVumtEqE8e5cCq2Z_f_7MtVeY";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        if (!sampleRateMatch) throw new Error('Could not find sample rate in mimeType.');
                        const sampleRate = parseInt(sampleRateMatch[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.onended = () => { setIsSpeaking(false); };
                        audio.play();
                    } else {
                        throw new Error('Invalid audio data received from API.');
                    }
                } catch (error) {
                    console.error('Error with Text-to-Speech:', error);
                    setIsSpeaking(false);
                }
            };
            
            // This component renders the final score screen.
            const FinalScoreScreen = () => (
                <div className="flex flex-col items-center justify-center text-center">
                    <div className="text-6xl mb-4 animate-bounce">üéâ</div>
                    <h2 className="text-4xl font-extrabold text-gray-800 mb-4 animate-fadeIn">
                        ‰Ω†Âæó‰∫Ü {score} ÂàÜÔºåÊª°ÂàÜ {questions.length} ÂàÜ!
                    </h2>
                    <p className="text-xl text-gray-600 mb-8 animate-fadeIn delay-100">
                        ‰Ω†ÁúüÊ£íÔºÅÂÜçÊé•ÂÜçÂéâÔºÅ
                    </p>
                    <button
                        onClick={handleRestartQuiz}
                        className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 px-8 rounded-full text-xl shadow-lg transition-all duration-300 transform hover:scale-110 active:scale-95"
                    >
                        ÈáçÊñ∞ÂºÄÂßã
                    </button>
                </div>
            );
            
            // This component renders the current question screen.
            const QuestionScreen = () => {
                const currentQuestionObj = questions[currentQuestion];
                return (
                    <>
                        <div className="flex justify-between items-center mb-6">
                            <div className="text-xl font-semibold text-gray-500">
                                <span className="text-purple-600">Á¨¨ {currentQuestion + 1} È¢ò</span>
                                 / {questions.length}
                            </div>
                        </div>
                        <div className="mb-8">
                            <div className="flex items-center gap-4">
                                <h1 className="text-3xl md:text-4xl font-bold text-gray-800 leading-tight animate-slideInLeft">
                                    {currentQuestionObj.questionText}
                                </h1>
                                <button
                                    onClick={handleTextToSpeech}
                                    disabled={isSpeaking}
                                    className="p-3 bg-purple-500 hover:bg-purple-600 text-white rounded-full shadow-lg transition-all duration-300 transform hover:scale-110 active:scale-95 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                >
                                    {isSpeaking ? (
                                        <svg className="animate-spin h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                    ) : (
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M12 21.35C16.97 18.06 20 14.59 20 10.25c0-3.32-2.69-6.01-6-6.01s-6 2.69-6 6.01c0 4.34 3.03 7.81 8 11.1zM12 4.25c2.9 0 5.25 2.35 5.25 5.25 0 3.12-2.31 5.95-6.75 9.47-4.44-3.52-6.75-6.35-6.75-9.47 0-2.9 2.35-5.25 5.25-5.25zM12 6.75c-1.54 0-2.75 1.21-2.75 2.75h5.5c0-1.54-1.21-2.75-2.75-2.75z"></path>
                                            <path d="M14 13.5v-3c0-1.1-.9-2-2-2s-2 .9-2 2v3h4z"></path>
                                        </svg>
                                    )}
                                </button>
                            </div>
                            {currentQuestionObj.pinyin && <p className="text-lg text-gray-500 mt-2">{currentQuestionObj.pinyin}</p>}
                        </div>
                        <div className="flex flex-col space-y-4">
                            {currentQuestionObj.type === 'multiple-choice' &&
                                currentQuestionObj.answerOptions.map((answerOption, index) => (
                                    <button
                                        key={index}
                                        onClick={() => handleMultipleChoiceClick(answerOption.isCorrect)}
                                        className={`
                                            w-full text-left py-4 px-6 rounded-2xl border-2 transition-all duration-300
                                            text-xl font-medium shadow-md
                                            ${
                                                answered
                                                    ? answerOption.isCorrect
                                                        ? 'bg-green-500 border-green-600 text-white animate-scaleUp'
                                                        : lastCorrect === false && !answerOption.isCorrect
                                                            ? 'bg-red-500 border-red-600 text-white animate-scaleUp'
                                                            : 'bg-gray-200 border-gray-300 text-gray-700 hover:bg-gray-300 cursor-not-allowed'
                                                    : 'bg-white border-purple-300 text-gray-800 hover:bg-purple-100 transform hover:-translate-y-1'
                                            }
                                        `}
                                        disabled={answered}
                                    >
                                        {answerOption.answerText}
                                    </button>
                                ))
                            }
                            {currentQuestionObj.type === 'fill-in-the-blank' &&
                                <div className="flex flex-col items-center space-y-4">
                                    <input
                                        type="text"
                                        value={fillInAnswer}
                                        onChange={(e) => setFillInAnswer(e.target.value)}
                                        className="w-full md:w-2/3 p-4 text-center text-2xl rounded-2xl border-2 border-purple-300 focus:outline-none focus:ring-4 focus:ring-purple-200 transition-all duration-300"
                                        placeholder="Âú®Ê≠§ËæìÂÖ•Á≠îÊ°à"
                                        disabled={answered}
                                    />
                                    <button
                                        onClick={handleFillInSubmit}
                                        className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 px-8 rounded-full text-xl shadow-lg transition-all duration-300 transform hover:scale-105 active:scale-95"
                                        disabled={answered}
                                    >
                                        Êèê‰∫§
                                    </button>
                                </div>
                            }
                        </div>
                        <div className="mt-8 flex justify-center items-center flex-col">
                            {!answered && (
                                <button
                                    onClick={handleGetHint}
                                    disabled={isHintLoading}
                                    className="bg-yellow-400 hover:bg-yellow-500 text-gray-800 font-bold py-3 px-6 rounded-full text-lg shadow-lg transition-all duration-300 transform hover:scale-105 active:scale-95 disabled:bg-gray-400 disabled:cursor-not-allowed mb-4"
                                >
                                    {isHintLoading ? (
                                        <span className="flex items-center gap-2">
                                            <svg className="animate-spin h-5 w-5 text-gray-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            Âä†ËΩΩÊèêÁ§∫...
                                        </span>
                                    ) : (
                                        'Ëé∑ÂèñÊèêÁ§∫ ‚ú®'
                                    )}
                                </button>
                            )}
                            {hint && (
                                <div className="bg-gray-100 p-4 rounded-2xl shadow-inner text-gray-700 text-base animate-fadeIn border-2 border-gray-200 w-full mb-4">
                                    {hint}
                                </div>
                            )}
                            {answered && (
                                <div className="flex justify-center items-center flex-col animate-fadeIn">
                                    <div
                                        className={`p-4 rounded-full font-bold text-xl mb-4 shadow-lg ${lastCorrect ? 'bg-green-600 text-white' : 'bg-red-600 text-white'}`}
                                    >
                                        {lastCorrect ? '‚úÖ Á≠îÂØπ‰∫ÜÔºÅ' : '‚ùå Á≠îÈîô‰∫ÜÔºÅ'}
                                    </div>
                                    <button
                                        onClick={handleNextQuestion}
                                        className="bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg transition-all duration-300 transform hover:scale-105 active:scale-95"
                                    >
                                        {currentQuestion + 1 === questions.length ? 'Êü•ÁúãÊàêÁª©' : '‰∏ã‰∏ÄÈ¢ò'}
                                    </button>
                                </div>
                            )}
                        </div>
                    </>
                );
            };

            return (
                <div className="flex items-center justify-center min-h-screen bg-gradient-to-br from-pink-300 to-purple-400 p-4">
                    <div className="w-full max-w-2xl bg-white rounded-3xl shadow-2xl p-8 md:p-12 transform transition-all duration-500 hover:scale-105 border-4 border-white animate-scaleIn">
                        {showScore ? <FinalScoreScreen /> : <QuestionScreen />}
                    </div>
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
